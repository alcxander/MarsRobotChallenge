---------------------------------------------------------------


![CodeRabbit Pull Request Reviews](https://img.shields.io/coderabbit/prs/github/alcxander/MarsRobotChallenge?utm_source=oss&utm_medium=github&utm_campaign=alcxander%2FMarsRobotChallenge&labelColor=171717&color=FF570A&link=https%3A%2F%2Fcoderabbit.ai&label=CodeRabbit+Reviews)


---------------------------------------------------------------


resources to consider

storage is no real quick challenge, maybe schema it out so it can be reviesd later, likely going to use prisma or similar if I go typescript. Could use noSQL either. Not sure what I need to define.

Some assumptions, whole thing runs locally, need to trim need for env keys, avoid passing keys from machine to machine. mayb eneed to revisit what storage tech is used. Would like to do something that is easy peasy to enable for another user on another machine. 

Let's set up a database with latest transactions/actions for the robot. Worried about latest state action on the bot and what steps it's taken but I don't want to get caught up managing some global state parameters for the bots steps that the CLI needs special actions for. Maybe we build the table with a session ID to tackle steps, so we have seeded database with maps it can pull from, then when we 'start' a session we pick a tseeded table at random, a start location, then apply the sequence of steps to solve the challenge but we create a session to store this against and ID it on the screen somewhere and in the output for the CLI. if we have a session we can map the routes to the session, and as steps are taken we can hold that as the last state of the bot to pull down. maybe we can push completed steps to a history table for reference to recall. if a session is incomplete we can mark it as incompleted or end step is listed as the last step they took when archived.


what components am I going to need here:

robot class/thing (facing, battery, samples collected, visited cells(should this be robot or terrain or a separate object for history), )
terrain thing (cell, contents, positioning)
commands (processes the actual requests for the robot when doing things like, sequences of commands and handles the logic of what to do when you hit an obstacle or a resource etc.)
a service of some sort to orchestrate these together into a 'function'

need to keep these separate from other things so these are reusable in the API and REST services

cli layer (never built one of these before)
rest api (this comes from page layouts really, should be self done by projce structure)
rest client (takes in the json posts to API shows result, likely be connected to the front end somewhere)

that's the communication layer

visualising and maps

likely going to exist in the app alongside the pages with a simple visualisation page. need some way to cordon off sessions

don't forget! 
battery costs, is that it's own typing on the move sets that can be peformed?
back of fstrategies, put in a 1 check sum at the start of every maneuver. also a 0 check as well to give up why not
terrain seeding strategies
json linter for examples provided, need to extend them to include session IDs,
unit tests - code rabbit for this. Need something to know the cli works

two routes here, attempted publishing on npmjs and then pulling the package back down 
----------------------


building in cli should i try something like build an application from scratch dependency by dependency or should i 
build a web application like normal and extend it out to accommodate cli......hmmmmmm

----------------------

29th 07 2025

getting a skeleton from an AI tool has made the start of this both easy and tough. Need to dig through and check the typing
across the project

on installation and first run note the install section has some weird dependencies, the system setup has picked some  dependencies that when cross checked aren't supported, will need to check and pull apart the dependencies and see what won't work.

need to install get functing and had to use --legacy-peer-deps #issue to get the system started, might try use some linter 
to see if I can pull apart these dependencies.


# testing initial skeleton

#question what does battery do on input? is that supposed to limit the battery intake that can be used per run?

#question At every moment, the robot contains an internal battery which provides a certain capacity, what is that capacity? going to assume infinite while starting out

#result the site runs, what do we note. input seems correct, output does not seem correct. we have visited cells, we have samples collected, final position, battery, direction facing. This partially presents correctly on the UI, the visited cells don't show numbers but map correctly. 

Looks like we stop at the boundary

{
  "terrain": [["Fe", "Se", "Si"], ["W", "Zn", "Fe"]],
  "battery": 10,
  "commands": ["F", "S", "R", "F"],
  "initialPosition": {
    "location": {"x": 0, "y": 0},
    "facing": "East"
  }
}

this use case should trigger the robot to want to refuel and should end up at 3 units. expected interaction:
10 units - move 7 - fail sample refuel (question here again about max, max can't be 10 as input shows 50 in test data) -refuel by 10 to 16 (-1 cost on action) - minus 8 for sample to 8 - minus 2 for turn right - minus 3 for forward to get to 3.

this result seems to work so the refuel seems to be working. 

#observation, alot of 'does this do what I think it does' is happening on project creation. It's like importing a complex component and now testing to see if it works as intended. Is this actually better than building it out? Maybe. :)

#observation we don't track when and what evasive procedures are invoked which makes tracking battery usage impossible, may add this just to make my own life easier for testing results


in simulation cases add section that says if battery is ever 0 while doing an action then break and produce error to show user

#question currently when a sample is collected should we remove that from the terrain so it can't be picked up a second time?

------------------------------------------

to build still, CLI, REST server, separate the existing API route maybe, build out the commander (maybe).

------------------------------------------


potential structure

app
src -
cli
server
logic

let's figure out what goes in each one


looking at the cli structure, lot's of it looks ok but WHY does it not reuse the logic that was built elsewhere in simulator.ts? Weird it did that so now will rebuild the cli script to (loosely along these lines) import the simulator, create instance of the simulator class in the CLI processor then just pass the input in.  

npx tsc lib/robot-simulator.ts -- make accessible version for CLI to run

cli tasks add bin and executable to CLI Script

renamed
chmod +x scripts/marsRobot.mjs
executable
npm installed (with legacy peer deps)
npm link needed for cli to work as desired in the requirements.

could also push this to npmjs and make it installable, that would also work.


---------------
30/07 14:18
rest server is working and serving
can run from command line the command 'marsrobotapi', that starts the server which can then be queried at /api/simulate

PS C:\Users\Dextosterone\git\MarsRobotChallenge> curl.exe -X POST http://localhost:3000/api/simulate -H "Content-Type: application/json" -d @sample-input.json | ConvertFrom-Json | ConvertTo-Json -Depth 10
curl.exe :   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
At line:1 char:1
+ curl.exe -X POST http://localhost:3000/api/simulate -H "Content-Type: ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (  % Total    % ...  Time  Current:String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   444    0   191  100   253  31373  41557 --:--:-- --:--:-- --:--:-- 74000
{
    "VisitedCells":  [
                         {
                             "x":  0,
                             "y":  0
                         },
                         {
                             "x":  1,
                             "y":  0
                         },
                         {
                             "x":  1,
                             "y":  1
                         },
                         {
                             "x":  1,
                             "y":  2
                         },
                         {
                             "x":  2,
                             "y":  2
                         }
                     ],
    "SamplesCollected":  [
                             "Fe",
                             "Si"
                         ],
    "Battery":  24,
    "FinalPosition":  {
                          "Location":  {
                                           "x":  1,
                                           "y":  2
                                       },
                          "Facing":  "East"
                      }
}

PS C:\Users\Dextosterone\git\MarsRobotChallenge> 

-------------------------------------------------------

5-bug-simulator-not-checking-terrain-types

fixing this issue exposed another issue, the tsx compiled code for the cli bot lives in the same folder as the other simulator, not normally an issue but the router points its import at 
import { simulateRobot, type RobotInput } from "@/lib/robot-simulator"
and a next project SHOULD be picking the ts over the js but for some reason it isn't. 



